1) Мы хотим реализовать поиск за постоянное время O(1).

Решение: для поиска за постоянное время можно использовать HashMap, где ключ - это номер
телефона, а значение - это имя клиента. Операции вставки, удаления и поиска в HashMap выполняются за O(1).
Кол-во уникальных телефонов 18 758 328. Initial capacity HashMap должен быть степенью двойки, следовательно, число,
являющееся степенью двойки и большее 18 758 328 это 33 554 432.
Объем памяти:
        1. Пустое значение ключа в ячейке HashMap занимает 4 байта, следовательно:
           (33 554 432 - 18 758 328) * 4 байт = 59 184 416 байт - это объем памяти свободных ячеек в массиве ключей
        2. Ключ - телефон = 11 символов(по 2 байта) + заголовок(8 байт) + 4 байт =  34 байта
        3. 34 байта * 18 758 328 = 637 738 152 - это объем памяти занятых ячеек в массиве ключей
        4. Значение - имя клиента = 20 символов(по 2 байта) + заголовок(8 байт) + 4 байт =  52 байта
        5. 52 байта * 18 758 328 = 975 433 056 - это объем памяти значений
        3. Всего: 975 433 056 + 59 184 416 + 637 738 152 = 1 672 355 624 байт = 1.6 Гб
Ответ: 1.6 Гб.

2) Мы хотим занять как можно меньше памяти.

Решение: для уменьшения памяти можно использовать такую структуру данных как TreeMap.
TreeMap обеспечивает оптимальное использование памяти, но имеет худшую производительность
в операциях получения, добавления и удаления по сравнению с HashMap.
Объем памяти:
    1. Ключ - телефон = 11 символов(по 2 байта) + заголовок(8 байт) + 4 байт = 34 байта
    2. 34 байта * 18 758 328 = 637 738 152
    3. Значение - имя клиента = 20 символов(по 2 байта) + заголовок(8 байт) + 4 байт = 52 байта
    4. 52 байта * 18 758 328 = 975 433 056
    5. Всего: 975 433 056 + 637 738 152 = 1.5 Гб
Ответ: 1.5 Гб.